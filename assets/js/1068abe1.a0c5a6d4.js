"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[295],{3905:function(e,t,n){n.d(t,{Zo:function(){return l},kt:function(){return h}});var o=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=o.createContext({}),c=function(e){var t=o.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},l=function(e){var t=c(e.components);return o.createElement(p.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},u=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),u=c(n),h=r,m=u["".concat(p,".").concat(h)]||u[h]||d[h]||i;return n?o.createElement(m,a(a({ref:t},l),{},{components:n})):o.createElement(m,a({ref:t},l))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,a=new Array(i);a[0]=u;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s.mdxType="string"==typeof e?e:r,a[1]=s;for(var c=2;c<i;c++)a[c]=n[c];return o.createElement.apply(null,a)}return o.createElement.apply(null,n)}u.displayName="MDXCreateElement"},4714:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return p},metadata:function(){return c},toc:function(){return l},default:function(){return u}});var o=n(7462),r=n(3366),i=(n(7294),n(3905)),a=["components"],s={sidebar_position:3},p="Health Checks",c={unversionedId:"docs/operations/healthchecks",id:"docs/operations/healthchecks",isDocsHomePage:!1,title:"Health Checks",description:"Recommended Components",source:"@site/docs/docs/operations/healthchecks.md",sourceDirName:"docs/operations",slug:"/docs/operations/healthchecks",permalink:"/nodejs-reference-architecture/docs/operations/healthchecks",editUrl:"https://github.com/nodeshift/nodejs-reference-architecture/docs/docs/operations/healthchecks.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Fault Tolerance",permalink:"/nodejs-reference-architecture/docs/operations/failurehandling"},next:{title:"Logging",permalink:"/nodejs-reference-architecture/docs/operations/logging"}},l=[{value:"Recommended Components",id:"recommended-components",children:[]},{value:"Guidance",id:"guidance",children:[{value:"Probe type",id:"probe-type",children:[]},{value:"Port",id:"port",children:[]},{value:"Response",id:"response",children:[]},{value:"Endpoints",id:"endpoints",children:[]},{value:"Frequency of checking",id:"frequency-of-checking",children:[]},{value:"Example code and configuration",id:"example-code-and-configuration",children:[]}]}],d={toc:l};function u(e){var t=e.components,n=(0,r.Z)(e,a);return(0,i.kt)("wrapper",(0,o.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"health-checks"},"Health Checks"),(0,i.kt)("h2",{id:"recommended-components"},"Recommended Components"),(0,i.kt)("p",null,"We don't recommend the use of a module to add health checks to your application. It's\nbest to stick with a minimal implementation for most cases. The tradeoff between the amount\nof code you need to add to your application for a minimal implementation versus\nthe costs of adding a new dependency leads us to recommend adding the code directly.\nExamples of how to add this code to your application are provided in the Guidance section."),(0,i.kt)("h2",{id:"guidance"},"Guidance"),(0,i.kt)("p",null,"Kubernetes includes built in liveness and readiness monitoring and document\nrequirements for these endpoints. We recommended following the\nkubernetes requirements as they are well defined, broadly used, and make\nyour application ready for Kubernetes deployment even if you initially use\nsomething else."),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/"},"Kubernetes liveness and readiness probes")," offer three different options: Probe type, port and response as described in the\nsections which follow."),(0,i.kt)("h3",{id:"probe-type"},"Probe type"),(0,i.kt)("p",null,"We recommend using an HTTP probe type (",(0,i.kt)("inlineCode",{parentName:"p"},"httpGet"),"). It demonstrates that the HTTP\nserver is up and responding to requests and is the most commonly used probe\ntype for services that expose HTTP as part of their function."),(0,i.kt)("p",null,"When using a Service Mesh (Istio), there are are potential\nissues that you need to address. If you have mutual TLS enabled,\nusing ",(0,i.kt)("inlineCode",{parentName:"p"},"httpGet")," probes with Istio requires some specific configuration. Check the Istio\n",(0,i.kt)("a",{parentName:"p",href:"https://istio.io/docs/ops/configuration/mesh/app-health-check/"},"guide")," to see\nthe options available when using HTTP request. If this configuration is\nnot practical for your deployment then TCP probes provide less coverage but\nare simpler to support."),(0,i.kt)("h3",{id:"port"},"Port"),(0,i.kt)("p",null,"We recommend responding to probes from the same port as the application server.\nIts simple, common, and demonstrates that the HTTP server is up and responding\nto requests."),(0,i.kt)("p",null,"By listening on the same port, it makes it easy to be certain that the container\ndoes not start responding to probes until it is ready to respond with\napplication traffic."),(0,i.kt)("h3",{id:"response"},"Response"),(0,i.kt)("p",null,"The response does not need to return any data, but status must be ",(0,i.kt)("inlineCode",{parentName:"p"},"200/OK"),". For\nhumans, it may be useful to return a minimal response body, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"ok"),"."),(0,i.kt)("p",null,"It may be tempting (particularly based on\ntutorials available on the web) to do additional internal state checks\nor checks on the availability of dependencies."),(0,i.kt)("p",null,"For liveness probes in particular\nthis can often do more harm than good as the end result is the container\nbeing restarted. For example, if a database used by the application is\ndown, restarting the container in which the Node.js application using that\ndatabase runs, is unlikely to help and can hurt but adding the additional\nload of continuously restarting containers."),(0,i.kt)("p",null,"For readiness probes, there are advanced use cases where it makes sense\nfor the service to modify its probe states to\nparticipate in container orchestration. For example, stopping responding on\n/readyz and allowing active connections to drain on the main port. When these\nrequirements exist it makes sense to implement a more complete readiness\nendpoint. In other cases it is better to stick to the\nsimple implementation. For example, in the case of a database that is\ndown, it is better to respond indicating there is a problem with the database\nversus failing the readiness check as that results in the loss of the\nability to provided 5xx responses to requests so that the client\nknows what's wrong."),(0,i.kt)("h3",{id:"endpoints"},"Endpoints"),(0,i.kt)("p",null,"We recommend that you use consistent naming for your endpoints across micro-services. ",(0,i.kt)("inlineCode",{parentName:"p"},"/readyz")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"/livez")," are common choices for the endpoints for the readiness and\nliveness probes, respectively."),(0,i.kt)("p",null,"Any route name can work if it agrees with the probe configuration, but in the\nabsence of some requirement by the tooling, best to use names that have a\nclear relationship to their purpose. ",(0,i.kt)("inlineCode",{parentName:"p"},"/healthz")," is not clear as to whether it is\nliveness or readiness. Because\n",(0,i.kt)("a",{parentName:"p",href:"https://developers.redhat.com/blog/2020/11/10/you-probably-need-liveness-and-readiness-probes"},"the differences between them are important"),",\nit's best to clarify."),(0,i.kt)("p",null,'The "z" at the end of ',(0,i.kt)("inlineCode",{parentName:"p"},"/readyz")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"/livez"),' are a pattern called "z pages" that\nis a pattern used by ',(0,i.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/reference/using-api/health-checks/"},"internal Kubernetes services")," and has also been adopted by some other projects like ",(0,i.kt)("a",{parentName:"p",href:"https://opencensus.io/zpages/"},"OpenCensus"),"."),(0,i.kt)("h3",{id:"frequency-of-checking"},"Frequency of checking"),(0,i.kt)("p",null,"Since probe states shouldn't change once the application is serving traffic,\nthere is no need for aggressive probe periods. The initial delay for the liveness\nprobe should be ample enough for application startup. If its too short,\nKubernetes will keep terminating the container before it serves traffic. Since\nthe only typical reason to not respond to a readiness probe once the application\nis up is that the application is exiting on container termination, Kubernetes\nwill already know that the container is terminating. Excessively frequent\nchecking here can also be counter productive."),(0,i.kt)("p",null,"We recommend that you don't specify specific values for your application and\nuse the cluster defaults unless your application needs more time to\nstartup (readiness) or to respond to liveness checks when under load."),(0,i.kt)("h3",{id:"example-code-and-configuration"},"Example code and configuration"),(0,i.kt)("p",null,"It is easy to add simple endpoints with with pure Express.js,\nor your framework of choice. For example with Express:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'const app = require("express")();\n\n// Note that when collecting metrics, the management endpoints should be\n// implemented before the instrumentation that collects metrics, so that\n// these endpoints are not counted in the metrics.\napp.get("/readyz", (req, res) => res.status(200).json({ status: "ok" }));\napp.get("/livez", (req, res) => res.status(200).json({ status: "ok" }));\n\n// ... rest of app...\n\napp.listen();\n')),(0,i.kt)("p",null,"The kubernetes endpoints exposed by the application have to agree with the probe configuration:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"readinessProbe:\n  httpGet:\n    path: /readyz\n    port: 3000\nlivenessProbe:\n  httpGet:\n    path: /livez\n    port: 3000\n")))}u.isMDXComponent=!0}}]);